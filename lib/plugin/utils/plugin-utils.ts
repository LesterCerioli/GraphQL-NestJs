import * as ts from 'typescript';
import { Type, TypeFlags, ObjectFlags, TypeFormatFlags, Node, SyntaxKind, TypeChecker, ObjectType } from 'typescript';
import { MetadataTypeDef } from '../visitors/model-class.visitor';

export function getDefaultTypeFormatFlags(enclosingNode: Node) {
  let formatFlags =
    TypeFormatFlags.UseTypeOfFunction |
    TypeFormatFlags.NoTruncation |
    TypeFormatFlags.UseFullyQualifiedType |
    TypeFormatFlags.WriteTypeArgumentsOfSignature;
  if (enclosingNode && enclosingNode.kind === SyntaxKind.TypeAliasDeclaration)
    formatFlags |= TypeFormatFlags.InTypeAlias;
  return formatFlags;
}


export function getText(
  type: Type,
  typeChecker: TypeChecker,
  enclosingNode?: Node,
  typeFormatFlags?: TypeFormatFlags,
) {
  if (!typeFormatFlags) {
    typeFormatFlags = getDefaultTypeFormatFlags(enclosingNode);
  }
  const compilerNode = !enclosingNode ? undefined : enclosingNode;
  return typeChecker.typeToString(type, compilerNode, typeFormatFlags);
}

export function hasFlag(type: Type, flag: TypeFlags) {
  return (type.flags & flag) === flag;
}
export function hasObjectFlag(type: Type, flag: ObjectFlags) {
  return ((type as ObjectType).objectFlags & flag) === flag;
}
export function isArray(type: Type) {
  const symbol = type.getSymbol();
  if (!symbol) {
    return false;
  }
  return symbol.getName() === 'Array' && getTypeArguments(type).length === 1;
}

export function getTypeArguments(type: Type) {
  return (type as any).typeArguments || [];
}

export function isBoolean(type: Type) {
  return hasFlag(type, TypeFlags.Boolean);
}

export function isString(type: Type) {
  return hasFlag(type, TypeFlags.String);
}

export function isNumber(type: Type) {
  return hasFlag(type, TypeFlags.Number);
}

export function isInterface(type: Type) {
  return hasObjectFlag(type, ObjectFlags.Interface);
}

export function isEnum(type: Type) {
  const hasEnumFlag = hasFlag(type, TypeFlags.Enum);
  if (hasEnumFlag) {
    return true;
  }
  if (isEnumLiteral(type)) {
    return false;
  }
  const symbol = type.getSymbol();
  if (!symbol) {
    return false;
  }
  const valueDeclaration = symbol.valueDeclaration;
  if (!valueDeclaration) {
    return false;
  }
  return valueDeclaration.kind === SyntaxKind.EnumDeclaration;
}

export function isEnumLiteral(type: Type) {
  return hasFlag(type, TypeFlags.EnumLiteral) && !type.isUnion();
}


export function getMemberTypeFromTypeChecker(node: ts.Node, typeChecker: ts.TypeChecker): MetadataTypeDef {
  const type =  typeChecker.getTypeAtLocation(node)

  return getTypeReference(type, typeChecker);
}

function getTypeReference(
  type: ts.Type,
  typeChecker: ts.TypeChecker,
): MetadataTypeDef {
  const res = {arrayType: false, typeName: '' };

  if (isArray(type)) {
    const arrayType = getTypeArguments(type)[0];
    const elementType = getTypeReference(arrayType, typeChecker);
    if (!elementType) {
      return undefined;
    }

    return {...elementType, arrayType: true};
  }
  if (isBoolean(type)) {
    return {...res, typeName: Boolean.name};
  }
  if (isNumber(type)) {
    return {...res, typeName: Number.name};
  }
  if (isString(type)) {
    return {...res, typeName: String.name};
  }
  if (isPromiseOrObservable(getText(type, typeChecker))) {
    const typeArguments = getTypeArguments(type);
    const elementType = getTypeReference(
      typeArguments[0],
      typeChecker,
    );
    if (!elementType) {
      return undefined;
    }
    return elementType;
  }
  if (type.isClass()) {
    return {...res, typeName: getText(type, typeChecker)};
  }
  try {
    const text = getText(type, typeChecker);
    if (text === Date.name) {
      return {...res, typeName: Date.name};
    }
    if (isOptionalBoolean(text)) {
      return {...res, typeName: Boolean.name}
    }
    if (isEnum(type)) {
      return {...res, typeName: text};
    }

    const isEnumMember =
      type.symbol && type.symbol.flags === ts.SymbolFlags.EnumMember;

    if (isEnumMember) {
      type = typeChecker.getDeclaredTypeOfSymbol((type.symbol as any).parent);
      if (!type) {
        return undefined;
      }
      return {...res, typeName: text};
    }

    const autoEnumUnion = isAutoGeneratedEnumUnion(type, typeChecker);

    if (autoEnumUnion) {
      return getTypeReference(autoEnumUnion, typeChecker)
    }

    if (isAutoGeneratedTypeUnion(type)) {
      const types = (type as ts.UnionOrIntersectionType).types;
      return getTypeReference(types[types.length - 1], typeChecker);
    }

    if (
      text === 'any' ||
      text === 'unknown' ||
      text === 'object' ||
      isInterface(type) ||
      (type.isUnionOrIntersection() && !isEnum(type))
    ) {
      return {...res, typeName: 'Object'};
    }
    if (type.aliasSymbol) {
      return {...res, typeName: 'Object'};
    }
    return {...res, typeName: 'Object'};
  } catch {
    return {...res, typeName: 'Object'};
  }
}

export function isPromiseOrObservable(type: string) {
  return type.includes('Promise') || type.includes('Observable');
}


/**
 * when "strict" mode enabled, TypeScript transform the enum type to a union composed of
 * the enum values and the undefined type. Hence, we have to lookup all the union types to get the original type
 */
export function isAutoGeneratedEnumUnion(
  type: ts.Type,
  typeChecker: ts.TypeChecker,
): ts.Type {
  if (type.isUnionOrIntersection() && !isEnum(type)) {
    if (!type.types) {
      return undefined;
    }
    const undefinedTypeIndex = type.types.findIndex(
      (type: any) => type.intrinsicName === 'undefined',
    );
    if (undefinedTypeIndex < 0) {
      return undefined;
    }

    // "strict" mode for enums
    let parentType = undefined;
    const isParentSymbolEqual = type.types.every((item, index) => {
      if (index === undefinedTypeIndex) {
        return true;
      }
      if (!item.symbol) {
        return false;
      }
      if (
        !(item.symbol as any).parent ||
        item.symbol.flags !== ts.SymbolFlags.EnumMember
      ) {
        return false;
      }
      const symbolType = typeChecker.getDeclaredTypeOfSymbol(
        (item.symbol as any).parent,
      );
      if (symbolType === parentType || !parentType) {
        parentType = symbolType;
        return true;
      }
      return false;
    });
    if (isParentSymbolEqual) {
      return parentType;
    }
  }
  return undefined;
}

/**
 * when "strict" mode enabled, TypeScript transform the type signature of optional properties to
 * the {undefined | T} where T is the original type. Hence, we have to extract the last type of type union
 * @param type
 */
export function isAutoGeneratedTypeUnion(type: ts.Type): boolean {
  if (type.isUnionOrIntersection() && !isEnum(type)) {
    if (!type.types) {
      return false;
    }
    const undefinedTypeIndex = type.types.findIndex(
      (type: any) => type.intrinsicName === 'undefined',
    );

    // "strict" mode for non-enum properties
    if (type.types.length === 2 && undefinedTypeIndex >= 0) {
      return true;
    }
  }
  return false;
}


/**
 * when "strict" mode enabled, TypeScript transform optional boolean properties to "boolean | undefined"
 * @param text
 */
function isOptionalBoolean(text: string) {
  return typeof text === 'string' && text === 'boolean | undefined';
}
